const getAppHandler = require('../../src/getAppHandler');
const MockAppBuilder = require('../utils/mock_app_builder');
const MockEventBuilder = require('../utils/mock_event_builder');
const mockEvent = require('../utils/default_app/mock_event.json');

describe('testing error handling', () => {
	test('throws random error and verify output', async () => {
		const errorMsg = 'verify error catch';
		const mockCallback = jest.fn(() => {
			throw new Error(errorMsg);
		});

		const app = new MockAppBuilder().setDefaultActionFunction(mockCallback).build();
		let handler = getAppHandler(app);

		const response = await handler(mockEvent, {});
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.message).toBe(errorMsg);
	});

	test('response status 100 - fetch throws error - verify output', async () => {
		const mockCallback = jest.fn(async (data) => {
			const fetch = data.libs.fetch;
			let url = 'https://httpbin.org/status/100';

			let r = await fetch(url, {
				method: 'GET'
			});
			return r;
		});

		const app = new MockAppBuilder().setDefaultActionFunction(mockCallback).build();

		let handler = getAppHandler(app);

		const response = await handler(mockEvent, {});
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.message).toMatch(/100/);
	});

	test('bad request :: response status 400 - fetch throws error - verify output', async () => {
		const response = await testResponse(400);
		expect(response.message).toMatch(/Bad Request/);
	});

	test('unauthorized :: response status 401 - fetch throws error - verify output', async () => {
		const response = await testResponse(401);
		expect(response.message).toMatch(/UNAUTHORIZED/);
	});

	test('forbidden :: response status 403 - fetch throws error - verify output', async () => {
		const response = await testResponse(403);
		expect(response.message).toMatch(/Forbidden/);
	});

	test('not found :: response status 404 - fetch throws error - verify output', async () => {
		const response = await testResponse(404);
		expect(response.message).toMatch(/Not Found/);
	});

	test('internal error :: response status 500 - fetch throws error - verify output', async () => {
		const response = await testResponse(500);
		expect(response.message).toMatch(/Internal Server Error/);
	});
});

const testResponse = async (status) => {
	const mockCallback = jest.fn(async (data) => {
		const fetch = data.libs.fetch;
		let url = `https://httpbin.org/status/${status}`;

		let r = await fetch(url, {
			method: 'GET'
		});
		return r;
	});

	const app = new MockAppBuilder().setDefaultActionFunction(mockCallback).build();

	let handler = getAppHandler(app);

	const response = await handler(mockEvent, {});
	expect(response).toBeDefined();
	expect(response.error).toBeTruthy();
	expect(response.errorCode).toBe(status);
	return response;
};

describe('disable error handling middleware', () => {
	test('actions method - disable http response middleware - get 400 response instead of error structure', async () => {
		const mockCallback = jest.fn(async (data) => {
			const fetch = data.libs.fetch;
			let url = 'https://httpbin.org/status/400';

			let r = await fetch(url, {
				method: 'GET'
			});
			return r;
		});

		const app = new MockAppBuilder().setDefaultActionFunction(mockCallback).disableDefaultActionHttpErrorHandling().build();

		let handler = getAppHandler(app);

		const response = await handler(mockEvent, {});
		expect(response).toBeDefined();
		expect(response.status).toBeTruthy();
		expect(response.status).toBe(400);
		expect(response.statusText).toMatch(/BAD REQUEST/);
	});

	test('auth method - disable http response middleware - get 400 response instead of error structure', async () => {
		const mockCallback = jest.fn(async (data) => {
			const fetch = data.libs.fetch;
			let url = 'https://httpbin.org/status/400';

			let r = await fetch(url, {
				method: 'GET'
			});
			return r;
		});
		const verifyAPI = mockCallback;
		const getConnectionName = async () => {};
		const auth = {
			type: 'custom',
			config: {
				getConnectionName
			},
			verifyAPI,
			auth_fields: []
		};
		const app = new MockAppBuilder().setAuth(auth).disableDefaultAuthHttpErrorHandling().build();

		const authMockEvent = new MockEventBuilder().setMethod('auth.verifyAPI').build();
		let handler = getAppHandler(app);

		const response = await handler(authMockEvent, {});
		expect(response).toBeDefined();
		expect(response.status).toBeTruthy();
		expect(response.status).toBe(400);
		expect(response.statusText).toMatch(/BAD REQUEST/);
	});

	test('auth method - using http response middleware - get 400 response in error structure', async () => {
		const mockCallback = jest.fn(async (data) => {
			const fetch = data.libs.fetch;
			let url = 'https://httpbin.org/status/400';

			let r = await fetch(url, {
				method: 'GET'
			});
			return r;
		});
		const verifyAPI = mockCallback;
		const getConnectionName = async () => {};
		const auth = {
			type: 'custom',
			config: {
				getConnectionName
			},
			verifyAPI,
			auth_fields: []
		};
		const app = new MockAppBuilder().setAuth(auth).build();

		const authMockEvent = new MockEventBuilder().setMethod('auth.verifyAPI').build();
		let handler = getAppHandler(app);

		const response = await handler(authMockEvent, {});
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.errorCode).toBe(400);
		expect(response.message).toMatch(/Bad Request/);
	});
});
