const get = require('lodash/get');
const isObject = require('lodash/isObject');
const isPlainObject = require('lodash/isPlainObject');
const { isNullOrUndefined } = require('./helpers');

const fetchPath = (bank, path) => (bank ? get(bank, path) : null);

let replaceValue = (value, bank, unflattenBank, prepareMappedFields) => {
	if (isObject(value)) {
		if (isPlainObject(value)) {
			for (const [k, v] of Object.entries(value)) {
				value[k] = replaceValue(v, bank, unflattenBank, prepareMappedFields);
			}
		} else if (Array.isArray(value)) {
			value = value.map((v) => {
				return replaceValue(v, bank, unflattenBank, prepareMappedFields);
			});
		}
		return value;
	}
	let re = /{{(?<fullKey>((?<nodeId>[a-z0-9-]+)__(?<path>(.+?))))}}/g;
	let parsedValue = value;
	const stringParsedValue = (value ?? '').toString();
	/** we replace the value on a copy of the value, so while iterating the regex matches results, the original value won't be affected
	 * */
	let newParsedValue = parsedValue;
	var regRes = re.exec(stringParsedValue);
	while (regRes) {
		if (regRes) {
			const isSingleSource = regRes.input === regRes[0];
			const { fullKey, nodeId, path } = regRes.groups;
			const mfKey = '__mappedFields.';
			const mfKeyIndex = fullKey.indexOf(mfKey);
			const isMappedField = mfKeyIndex !== -1;
			let valueToReplace;
			valueToReplace = fetchPath(unflattenBank[nodeId], path);

			if (isMappedField) {
				if (prepareMappedFields && Array.isArray(prepareMappedFields)) {
					prepareMappedFields.forEach((p) => {
						if (valueToReplace !== null && valueToReplace !== undefined) {
							valueToReplace = p(valueToReplace);
						}
					});
				}
			}

			// Fix "get first item" formula case where using `lodash.get` on `unflattenBank` doesn't work.
			// TODO remove the usage of unflattenBank altogether, and (another unrelated thing) - remove isMappedField concept.
			if (isNullOrUndefined(valueToReplace)) {
				valueToReplace = bank[fullKey];
			}

			if (isNullOrUndefined(valueToReplace)) {
				console.log(`${fullKey} is null or undefined, converting it to empty string`);
				/** if value is null or undefined (if value was missing in the previousVars or recieved from integration as null)
				 * we want to replace it as an empty string
				 * */
				valueToReplace = '';
			}

			// it means this is an array of multi item source, only acceptable scenario
			const isValueAnArray = isObject(valueToReplace) && Array.isArray(valueToReplace);

			const unparsedValueReplace = isValueAnArray || isSingleSource;

			if (unparsedValueReplace) {
				newParsedValue = valueToReplace;
			} else {
				newParsedValue = newParsedValue.replace(regRes[0], valueToReplace);
			}
		}
		regRes = re.exec(stringParsedValue);
	}

	let replacedValue = newParsedValue;

	return replacedValue;
};

module.exports = replaceValue;
