const isPlainObject = require('lodash/isPlainObject');
const methodNameHelper = require('./method-name-helper');
const { utils: paramTypeUtils } = require('./param-types');
const replaceValue = require('./replace-value');
const unflatPreviousVars = require('./unflat-previous-vars');
const _ = require('lodash');

const loopOverInputDataAndReplaceParams = (actionParams, inputData, previousVars, unflattenPreviousVars, prepareMappedFields) => {
	for (const key in inputData) {
		if (inputData.hasOwnProperty(key)) {
			const paramObject = paramTypeUtils.extractParamFromActionParams(actionParams, key);
			const paramType = paramTypeUtils.getParamTypeOfKey(actionParams, key);
			if (paramType && paramType.handler) {
				paramType.handler(paramObject, inputData, key, { previousVars, unflattenPreviousVars, prepareMappedFields });
			} else {
				const doesParamHasNestedParams = paramObject?.type === 'nested';
				if (isPlainObject(inputData[key]) && doesParamHasNestedParams) {
					const nestedParams = paramObject.params || [];
					loopOverInputDataAndReplaceParams(nestedParams, inputData[key], previousVars, unflattenPreviousVars, prepareMappedFields);
				} else {
					inputData[key] = replaceValue(inputData[key], previousVars, unflattenPreviousVars, prepareMappedFields);
				}
			}
		}
	}
};

const getParamsForMethod = (app, methodName) => {
	let params = [];
	let methodType = methodNameHelper.getRootObjectNameFromName(methodName);
	if (methodType) {
		const method = _.get(app, methodType);
		params = method?.params || [];
	}
	return params;
};

const prepareInputData = (app, methodName, inputData, previousVars, prepareMappedFields) => {
	// console.log('prepareInputData begin');
	const unflattenPreviousVars = unflatPreviousVars(previousVars);
	const actionParams = getParamsForMethod(app, methodName);
	loopOverInputDataAndReplaceParams(actionParams, inputData, previousVars, unflattenPreviousVars, prepareMappedFields);
	// console.log('prepareInputData end');
};

module.exports = prepareInputData;
