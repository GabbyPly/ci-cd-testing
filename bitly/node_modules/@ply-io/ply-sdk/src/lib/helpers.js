const _ = require('lodash');
const CUSTOM_MAPPINGS = 'ply_custom_';

const isNullOrUndefined = (value) => {
	return value === null || value === undefined;
};

const isNullOrUndefinedOrEmpty = (value) => {
	return isNullOrUndefined(value) || value === '';
};

const unflatten = (data) => {
	if (Object(data) !== data || Array.isArray(data)) return data;
	var regex = /\.?([^.[\]]+)|\[(\d+)\]/g,
		resultholder = {};
	for (var p in data) {
		var cur = resultholder,
			prop = '',
			m;
		while ((m = regex.exec(p))) {
			cur = cur[prop] || (cur[prop] = m[2] ? [] : {});
			prop = m[2] || m[1];
		}
		cur[prop] = data[p];
	}
	return resultholder[''] || resultholder;
};

const addUserCustomMappings = (mappings, input) => {
	Object.keys(input).forEach((key) => {
		if (key.startsWith(CUSTOM_MAPPINGS)) {
			mappings[key.substring(CUSTOM_MAPPINGS.length)] = input[key];
		}
	});
	return mappings;
};

const mapItem = (item, mappingValue) => {
	if (_.isFunction(mappingValue)) {
		return mappingValue(item);
	}
	return _.get(item, mappingValue, undefined);
};

const mapResultFromMethod = (mappings, methodResults, data) => {
	const { option, value } = mappings;
	if (!option || !value) {
		throw new Error('ac mapping does not have minimum mappings, option and value');
	}
	const { results } = methodResults;
	const { addFullItem } = data.input;
	mappings = addUserCustomMappings(mappings, data.input);

	return Object.assign(methodResults, {
		results: results.map((item) => {
			let res = Object.keys(mappings).reduce((val, key) => {
				return { ...val, [key]: mapItem(item, mappings[key]) };
			}, {});

			if (addFullItem === 'true') {
				res = { ...res, item };
			}
			return res;
		})
	});
};

module.exports = { isNullOrUndefined, isNullOrUndefinedOrEmpty, unflatten, mapResultFromMethod };
