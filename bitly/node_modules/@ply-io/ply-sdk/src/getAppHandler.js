const _ = require('lodash');
const getFetchForMethod = require('./lib/get-fetch-for-method');
const errors = require('./lib/errors');
const methodNameHelper = require('./lib/method-name-helper');
const { isNullOrUndefinedOrEmpty, mapResultFromMethod } = require('./lib/helpers');

const getParamsFromMethod = async (paramsArray, data) => {
	if (!_.isArray(paramsArray)) {
		return {
			error: 1,
			errorMessage: 'Params definition corrupted. not an array.'
		};
	}

	// Iterate every field in the param array.
	const allParamsArray = await Promise.all(paramsArray.map((param) => (_.isFunction(param) ? param(data) : param)));
	return _.flatten(allParamsArray);
};

const runMethodOptions = (app, methodName, methodResults, methodOptions, data) => {
	if (!methodResults) {
		return null;
	}

	// make sure we're not handling error result
	const isError = methodResults.errorCode;
	if (isError) {
		return methodResults;
	}

	const { acMode } = methodOptions;
	let newMethodResults = methodResults;
	if (acMode && methodNameHelper.isActions(methodName)) {
		const actionName = methodNameHelper.getRootObjectNameFromName(methodName);
		const action = _.get(app, actionName);
		if (!action) {
			throw new Error(`Error: Action not found: ${actionName}`);
		}
		const acMappingMethod = action['ac_mappings'];
		if (acMappingMethod) {
			if (_.isFunction(acMappingMethod)) {
				newMethodResults = acMappingMethod(methodResults); //deprecated
			} else if (_.isObject(acMappingMethod)) {
				newMethodResults = mapResultFromMethod(acMappingMethod, methodResults, data);
			} else {
				throw new Error(`Error: Unknown mappingHandler type: ${actionName}.ac_mappings`);
			}
		} else {
			throw new Error(`Error: Not found: ${actionName}.ac_mappings`);
		}
	}

	return newMethodResults;
};

const validateParamType = (app, methodName, data) => {
	if (methodNameHelper.isActions(methodName)) {
		const actionName = methodNameHelper.getRootObjectNameFromName(methodName);
		const action = _.get(app, actionName);
		if (!action || !action.params) {
			return;
		}

		action.params.forEach((param) => {
			const value = data.input[param.key];

			if (isNullOrUndefinedOrEmpty(value)) {
				if (param.required) {
					console.log(`throw error: ${param.name} is required`);
					throw new errors.AppError(`${param.name} is required`, 400);
				}
				// no value for this param
				// no need to validate, go on to the next param
				return;
			}

			// param has value:
			switch (param.type) {
				case 'integer':
					if (isNaN(value)) {
						console.log(`throw bad request error: ${param.name} is not a number`);
						throw new errors.AppError(`${param.name} is not a number`, 400);
					}
					break;
				default:
					break;
			}
		});
	}
};

const validateStructure = (app, methodName, methodResults) => {
	if (methodNameHelper.isActions(methodName)) {
		const actionName = methodNameHelper.getRootObjectNameFromName(methodName);
		const action = _.get(app, actionName);
		if (!action) {
			return;
		}
		if (action['skip_structure_validation']) {
			return;
		}

		const isMultiple = action['is_multiple'];
		if (isMultiple) {
			if (!methodResults || (!_.isArray(methodResults.results) && !methodResults.error)) {
				throw new Error('Response should be an object with a list of results. Example of the structure: { "results": [] } ');
			}
		}
	}
};

// Move this when organizing the code better.
const executeMethod = async (app, methodName, data, options) => {
	const methodOptions = options || {};

	// We need to decide what to run, it might be app method or not
	// Lets handle those who are not.
	//

	const method = _.get(app, methodName);
	data = data || {};
	// Inject needed context, for now, fetch

	data.libs = data.libs || {};
	data.libs.fetch = getFetchForMethod(app, methodName, data);
	data.libs.errors = errors;
	let methodResults;

	if (methodNameHelper.isParams(methodName)) {
		methodResults = getParamsFromMethod(method, data);
	} else if (method && _.isFunction(method)) {
		validateParamType(app, methodName, data);
		methodResults = await method(data);
	} else {
		throw new Error(`Error: Not found: ${methodName}`);
	}

	validateStructure(app, methodName, methodResults);
	methodResults = runMethodOptions(app, methodName, methodResults, methodOptions, data);

	return methodResults;
};

const handleError = (err) => {
	console.log('handleError', err);
	console.log('Stack:');
	console.log(err.stack);
	return {
		error: true,
		message: err.message,
		errorCode: err.errorCode
		// 'stack': err.stack
	};
};

const getAppHandler = (app) => {
	// eslint-disable-next-line no-unused-vars
	const lambdaHandler = async (event, context) => {
		// console.log(event);

		if (event.method) {
			try {
				let r = await executeMethod(app, event.method, event.data, event.options);
				return r;
			} catch (error) {
				return handleError(error);
			}
		}

		const response = {
			statusCode: 200,
			body: JSON.stringify('Hello from Lambda!')
		};
		return response;
	};
	return lambdaHandler;
};
module.exports = getAppHandler;
