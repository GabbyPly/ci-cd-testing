const getAppHandler = require('../../src/getAppHandler');
const MockAppBuilder = require('../utils/mock_app_builder');
const MockEventBuilder = require('../utils/mock_event_builder');

const multipleAction = {
	key: 'fake_multiple_integration',
	noun: 'Fake Multiple',
	title: 'Fake multiple integration',
	type: 'read',
	params: [],
	// handler: doSomething,
	is_multiple: true
};

const nonMultipleAction = {
	key: 'fake_integration',
	noun: 'Fake',
	title: 'Fake regular',
	type: 'read',
	params: [],
	handler: () => null,
	is_multiple: false
};
const multipleActionSkipStrucuteValidation = {
	key: 'fake_multiple_integration_skip_structure',
	noun: 'Fake Multiple',
	title: 'Fake multiple integration',
	type: 'read',
	params: [],
	// handler: doSomething,
	is_multiple: true,
	skip_structure_validation: true
};

const verifyAPI = () => {
	return {};
};
const getConnectionName = async () => {};
const auth = {
	type: 'custom',
	config: {
		getConnectionName
	},
	verifyAPI,
	auth_fields: []
};
describe('results validation', () => {
	test('return empty object - throw error', async () => {
		const response = await validateResponse(
			multipleAction,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return {};
			})
		);
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.message).toMatch(/Response should be an object with a list of results. /);
	});

	test('return list - throw error', async () => {
		const response = await validateResponse(
			multipleAction,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return [];
			})
		);
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.message).toMatch(/Response should be an object with a list of results. /);
	});

	test('return empty results object - throw error', async () => {
		const response = await validateResponse(
			multipleAction,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return { results: {} };
			})
		);
		expect(response).toBeDefined();
		expect(response.error).toBeTruthy();
		expect(response.message).toMatch(/Response should be an object with a list of results. /);
	});

	test('return correct result - all good', async () => {
		const response = await validateResponse(
			multipleAction,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return { results: [] };
			})
		);
		expect(response).toBeDefined();
		expect(response.error).toBeFalsy();
	});

	test('return null result - all good', async () => {
		const response = await validateResponse(
			nonMultipleAction,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return null;
			})
		);
		expect(response).toBeNull();
	});
	test('skip validation structure - all good', async () => {
		const response = await validateResponse(
			multipleActionSkipStrucuteValidation,
			// eslint-disable-next-line no-unused-vars
			jest.fn(async (data) => {
				return { stuff: 'doesnt matter' };
			})
		);
		expect(response).toBeDefined();
		expect(response.error).toBeFalsy();
	});

	test('not action method name - all good', async () => {
		// eslint-disable-next-line no-unused-vars
		multipleAction.handler = jest.fn(async (data) => {
			return {};
		});
		const app = new MockAppBuilder().addAction(multipleAction).setAuth(auth).build();
		const mockEvent = new MockEventBuilder().setMethod('auth.verifyAPI').build();
		let handler = getAppHandler(app);

		const response = await handler(mockEvent, {});
		expect(response).toBeDefined();
		expect(response.error).toBeFalsy();
	});
});

const validateResponse = async (action, mockCallback) => {
	action.handler = mockCallback;
	const app = new MockAppBuilder().addAction(action).build();
	const mockEvent = new MockEventBuilder().setMethod(`actions.${action.key}.handler`).build();
	let handler = getAppHandler(app);

	const response = await handler(mockEvent, {});
	return response;
};
