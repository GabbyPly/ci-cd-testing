const isString = require('lodash/isString');
const isPlainObject = require('lodash/isPlainObject');
const { PLY_LIST_SOURCE_PARAM, RAW_DATA_KEY } = require('./const');
const get = require('lodash/get');
const replaceValue = require('../replace-value');
const cloneDeep = require('lodash/cloneDeep');

const populateNewRowWithRawData = (newRow, originalRow) => {
	const rawData = cloneDeep(originalRow);
	newRow[RAW_DATA_KEY] = rawData;
};

const replaceTextOfRowWithDataFromSourceRow = (inputText, sourceRow, propertyValueCode) => {
	/**
	 * if propertyValueCode is equal to all the input of the string, then replace the inputText with the original type to prevent conversions from number to string
	 */
	const fullReplaceKeepType = propertyValueCode.input === propertyValueCode[0];
	if (fullReplaceKeepType) {
		return get(sourceRow, propertyValueCode.groups.code);
	}
	return inputText.replace(propertyValueCode[0], get(sourceRow, propertyValueCode.groups.code));
};

const extractPropertyValueCode = (value) => {
	const re = /{{(?<code>(.+?))}}/g;
	const codes = [];
	let regRes;
	while ((regRes = re.exec(value))) {
		if (regRes) {
			codes.push(regRes);
		}
	}
	return codes;
};

const buildRowValueFromListParam = (originalRow, newRow, paramEntry, previousVars, unflattenPreviousVars, prepareMappedFields) => {
	/**
	 * example originalRow:
	 * {
	 * 	ID: 1
	 * }
	 */
	const [paramKey, paramValue] = paramEntry;
	let replacedValue = replaceValue(paramValue, previousVars, unflattenPreviousVars, prepareMappedFields);

	const propertyValueCodes = extractPropertyValueCode(replacedValue);
	const needToReplaceText = isString(replacedValue);
	if (needToReplaceText) {
		propertyValueCodes.forEach((propertyValueCode) => {
			replacedValue = replaceTextOfRowWithDataFromSourceRow(replacedValue, originalRow, propertyValueCode);
		});
	}
	newRow[paramKey] = replacedValue;
	return newRow;
};

const buildRowFromListParams = (originalRow, listParams, previousVars, unflattenPreviousVars, prepareMappedFields, omitRawData) => {
	let newRow = cloneDeep(originalRow);
	newRow = Object.entries(listParams).reduce(
		(newRow, listParamEntry) =>
			buildRowValueFromListParam(originalRow, newRow, listParamEntry, previousVars, unflattenPreviousVars, prepareMappedFields),
		{}
	);

	if (!omitRawData) {
		populateNewRowWithRawData(newRow, originalRow);
	}

	return newRow;
};

const handler = (param, input, key, extraData) => {
	const { previousVars, unflattenPreviousVars, prepareMappedFields } = extraData;
	const sourceArrayExists = !!input[key][PLY_LIST_SOURCE_PARAM];

	let arrayReplaced = false;
	if (sourceArrayExists) {
		let sourceArray = replaceValue(input[key][PLY_LIST_SOURCE_PARAM], previousVars, unflattenPreviousVars, prepareMappedFields); // extract source of multi item param

		const sourceArrayIsValid = Array.isArray(sourceArray);
		if (sourceArrayIsValid) {
			delete input[key][PLY_LIST_SOURCE_PARAM]; // delete the extra ply_list_source param map

			// if at least one item of array is not a plain object,
			// wrap all items in an object with key called 'value'
			if (sourceArray.some((value) => !isPlainObject(value))) {
				sourceArray = sourceArray.map((value) => ({ value }));
			}

			const listParams = { ...input[key] };
			/**
			 * 	Example listParams:
			 * {
			 * 	somekey: 'this is my id {{ ID }}',
			 * 	otherkey: 'this is my name {{ Name }}'
			 * };
			 */

			// in case integration hasn't set any params in the list param, they expect to get the full array
			const copyFullList = Object.keys(listParams).length === 0;

			if (copyFullList) {
				input[key] = sourceArray;
			} else {
				input[key] = sourceArray.map((row) =>
					buildRowFromListParams(row, listParams, previousVars, unflattenPreviousVars, prepareMappedFields, param.omitRawData)
				);
			}

			arrayReplaced = true;
		}
	}
	if (!arrayReplaced) {
		delete input[key];
	}
};

module.exports = { handler };
