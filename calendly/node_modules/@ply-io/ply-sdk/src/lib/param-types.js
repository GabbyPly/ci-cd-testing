const isPlainObject = require('lodash/isPlainObject');
const { isNullOrUndefined } = require('./helpers');
const replaceValue = require('./replace-value');

const getMaxIndex = (inputData) => {
	const lengthsOfData = Object.values(inputData).map((data) => (Array.isArray(data) ? data.length : 1));
	return Math.max(...lengthsOfData);
};

const createArrayOfValues = (size, propertyValue) => {
	return Array(size).fill(propertyValue) || [];
};

const extractPropertyValueCode = (value) => {
	const re = /{{(?<code>(.+?))}}/g;
	const codes = [];
	let regRes;
	while ((regRes = re.exec(value))) {
		if (regRes) {
			codes.push(regRes);
		}
	}
	return codes;
};

const replaceTextOfRowWithDataFromSourceRow = (inputText, sourceRow, propertyValueCode) => {
	return inputText.replace(propertyValueCode[0], sourceRow[propertyValueCode.groups.code]);
};

const extractParamFromActionParams = (actionParams, key) => actionParams.find((p) => p.key === key);

const getParamTypeOfKey = (actionParams, key) => {
	if (!actionParams || !Array.isArray(actionParams)) {
		return null;
	}
	const param = extractParamFromActionParams(actionParams, key);
	const paramTypeUppercase = param?.type?.toUpperCase();
	if (paramTypeUppercase) {
		return PARAM_TYPES_MAP[paramTypeUppercase];
	}
	return null;
};

const PLY_LIST_SOURCE_PARAM = 'ply_list_source';

const PARAM_TYPES = [
	{
		code: 'list',
		handler: (input, key, extraData) => {
			const { previousVars, unflattenPreviousVars, prepareMappedFields } = extraData;
			const sourceExists = !!input[key][PLY_LIST_SOURCE_PARAM];

			let arrayReplaced = false;
			if (sourceExists) {
				const sourceValue = replaceValue(input[key][PLY_LIST_SOURCE_PARAM], previousVars, unflattenPreviousVars, prepareMappedFields); // extract source of multi item param

				const sourceValueValid = Array.isArray(sourceValue);
				if (sourceValueValid) {
					delete input[key][PLY_LIST_SOURCE_PARAM]; // delete the extra ply_list_source param map
					const complexDataTypeArray = sourceValue.some((value) => typeof value === 'object');

					if (Object.entries(input[key]).length == 0) {
						input[key] = sourceValue;
					} else {
						for (const [propertyKey, propertyValue] of Object.entries(input[key])) {
							let value = createArrayOfValues(sourceValue.length, propertyValue);

							// data from previousVars values
							value = value.map((valueRow) => replaceValue(valueRow, previousVars, unflattenPreviousVars, prepareMappedFields));

							// data from list values
							const propertyValueCodes = extractPropertyValueCode(propertyValue);
							if (complexDataTypeArray) {
								for (let propertyValueCode of propertyValueCodes) {
									if (propertyValueCode) {
										value = sourceValue.map((sourceItem, index) =>
											replaceTextOfRowWithDataFromSourceRow(value[index], sourceItem, propertyValueCode)
										);
									}
								}
							} else {
								value = [...sourceValue];
							}
							input[key][propertyKey] = value;
						}
					}

					arrayReplaced = true;
				}
			}
			if (!arrayReplaced) {
				delete input[key];
			}
			const data = input[key];
			let value = data;
			if (isPlainObject(data)) {
				const array = [];
				for (let index = 0; index < getMaxIndex(data); index++) {
					const element = {};
					for (const [inputKey, inputValue] of Object.entries(data)) {
						if (Array.isArray(inputValue)) {
							const actualIndex = index % inputValue.length; // for repeats
							element[inputKey] = !isNullOrUndefined(inputValue[actualIndex]) ? inputValue[actualIndex] : ''; // todo - check is null or undefined or non empty (0 equals to false)
						} else {
							element[inputKey] = inputValue;
						}
					}
					array.push(element);
				}
				value = array;
			}
			input[key] = value;
		}
	},
	{
		code: 'String'
	},
	{
		code: 'Number'
	},
	{
		code: 'Object'
	}
];

const PARAM_TYPES_MAP = PARAM_TYPES.reduce((obj, paramType) => ((obj[paramType.code.toUpperCase()] = paramType), obj), {});

const utils = {
	getParamTypeOfKey,
	extractParamFromActionParams
};

module.exports = {
	types: PARAM_TYPES_MAP,
	utils,
	PLY_LIST_SOURCE_PARAM
};
